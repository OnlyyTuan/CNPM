// bus-simulator.js - Gi·∫£ l·∫≠p xe bus di chuy·ªÉn THEO TUY·∫æN ƒê∆Ø·ªúNG
// Ch·∫°y: node bus-simulator.js

const axios = require('axios');

const BASE_URL = 'http://localhost:5000/api/v1';

// Waypoints cho t·ª´ng tuy·∫øn (l·∫•y t·ª´ database)
const ROUTE_WAYPOINTS = {
  R001: [], // S·∫Ω load t·ª´ API
  R002: [], // S·∫Ω load t·ª´ API
};

// C·∫•u h√¨nh xe bus v·ªõi tuy·∫øn ƒë∆∞·ªùng
const buses = [
  {
    id: 'B001',
    name: 'Xe 51A-12345',
    routeId: 'R001',
    currentWaypointIndex: 0,
    currentLat: null,
    currentLng: null,
    speed: 35,
    progress: 0, // 0-1, ti·∫øn tr√¨nh gi·ªØa 2 waypoint
  },
  {
    id: 'B002',
    name: 'Xe 51B-67890',
    routeId: 'R002',
    currentWaypointIndex: 0,
    currentLat: null,
    currentLng: null,
    speed: 30,
    progress: 0,
  },
  {
    id: 'B003',
    name: 'Xe 51C-11111',
    routeId: 'R001',
    currentWaypointIndex: 3, // B·∫Øt ƒë·∫ßu t·ª´ gi·ªØa tuy·∫øn
    currentLat: null,
    currentLng: null,
    speed: 0, // Xe ƒëang ƒë·ªó
    progress: 0,
  },
];

// Load waypoints t·ª´ API
async function loadRouteWaypoints(routeId) {
  try {
    const response = await axios.get(`${BASE_URL}/routes/${routeId}/waypoints`);
    ROUTE_WAYPOINTS[routeId] = response.data.waypoints;
    console.log(`‚úÖ Load ${ROUTE_WAYPOINTS[routeId].length} waypoints cho tuy·∫øn ${routeId}`);
  } catch (error) {
    console.error(`‚ùå L·ªói load waypoints cho ${routeId}:`, error.message);
  }
}

// T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm (ƒë∆°n gi·∫£n)
function getDistance(lat1, lng1, lat2, lng2) {
  const dlat = lat2 - lat1;
  const dlng = lng2 - lng1;
  return Math.sqrt(dlat * dlat + dlng * dlng);
}

// H√†m c·∫≠p nh·∫≠t v·ªã tr√≠ xe theo tuy·∫øn
async function updateBusLocation(bus) {
  try {
    const waypoints = ROUTE_WAYPOINTS[bus.routeId];
    if (!waypoints || waypoints.length === 0) return;
    
    // L·∫•y waypoint hi·ªán t·∫°i v√† waypoint ti·∫øp theo
    const currentWp = waypoints[bus.currentWaypointIndex];
    const nextWpIndex = (bus.currentWaypointIndex + 1) % waypoints.length;
    const nextWp = waypoints[nextWpIndex];
    
    // Debug: Check if waypoints have valid data
    if (!currentWp || !nextWp || typeof currentWp.latitude === 'undefined' || typeof nextWp.latitude === 'undefined') {
      console.error(`‚ùå Invalid waypoint data for ${bus.name}:`, {currentWp, nextWp});
      return;
    }
    
    // N·∫øu ch∆∞a c√≥ v·ªã tr√≠, b·∫Øt ƒë·∫ßu t·ª´ waypoint ƒë·∫ßu
    if (bus.currentLat === null) {
      bus.currentLat = parseFloat(currentWp.latitude);
      bus.currentLng = parseFloat(currentWp.longitude);
    }
    
    // T√≠nh b∆∞·ªõc di chuy·ªÉn (d·ª±a tr√™n t·ªëc ƒë·ªô)
    // 1 km/h ‚âà di chuy·ªÉn 0.00001 ƒë·ªô m·ªói gi√¢y (x·∫•p x·ªâ cho Vi·ªát Nam)
    const stepSize = (bus.speed / 3600) * 0.01; // m·ªói 2 gi√¢y
    
    // T√≠nh kho·∫£ng c√°ch c√≤n l·∫°i ƒë·∫øn waypoint ti·∫øp theo
    const distanceToNext = getDistance(
      bus.currentLat, bus.currentLng,
      nextWp.latitude, nextWp.longitude
    );
    
    // N·∫øu g·∫ßn ƒë·∫øn waypoint ti·∫øp theo, chuy·ªÉn sang waypoint m·ªõi
    if (distanceToNext < stepSize * 2) {
      bus.currentWaypointIndex = nextWpIndex;
      bus.currentLat = parseFloat(nextWp.latitude);
      bus.currentLng = parseFloat(nextWp.longitude);
      bus.progress = 0;
      
      // Thay ƒë·ªïi t·ªëc ƒë·ªô ng·∫´u nhi√™n khi ƒë·∫øn waypoint
      if (bus.speed > 0) {
        bus.speed = Math.max(20, Math.min(60, bus.speed + (Math.random() * 20 - 10)));
      }
      
      console.log(`  üöè ${bus.name} ƒë·∫øn ${nextWp.stop_name || 'ƒëi·ªÉm ' + nextWpIndex}`);
    } else {
      // Di chuy·ªÉn v·ªÅ ph√≠a waypoint ti·∫øp theo
      bus.progress += stepSize / distanceToNext;
      bus.progress = Math.min(1, bus.progress);
      
      // Interpolate gi·ªØa waypoint hi·ªán t·∫°i v√† ti·∫øp theo
      const fromLat = parseFloat(currentWp.latitude);
      const fromLng = parseFloat(currentWp.longitude);
      const toLat = parseFloat(nextWp.latitude);
      const toLng = parseFloat(nextWp.longitude);
      
      bus.currentLat = fromLat + (toLat - fromLat) * bus.progress;
      bus.currentLng = fromLng + (toLng - fromLng) * bus.progress;
    }
    
    // G·ª≠i v·ªã tr√≠ m·ªõi l√™n server
    await axios.put(
      `${BASE_URL}/buses/${bus.id}/location`,
      {
        latitude: bus.currentLat,
        longitude: bus.currentLng,
        speed: bus.speed,
      }
    );
    
    console.log(
      `[${new Date().toLocaleTimeString('vi-VN')}] ${bus.name}: ` +
      `lat=${bus.currentLat.toFixed(6)}, lng=${bus.currentLng.toFixed(6)}, ` +
      `speed=${bus.speed.toFixed(1)} km/h, waypoint ${bus.currentWaypointIndex}‚Üí${nextWpIndex}`
    );
  } catch (error) {
    console.error(`‚ùå L·ªói c·∫≠p nh·∫≠t ${bus.name}:`, error.message);
  }
}

// Kh·ªüi t·∫°o v√† ch·∫°y simulator
async function startSimulator() {
  console.log('üöå B·∫Øt ƒë·∫ßu gi·∫£ l·∫≠p xe bus di chuy·ªÉn THEO TUY·∫æN ƒê∆Ø·ªúNG...\n');
  
  // Load waypoints cho t·∫•t c·∫£ c√°c tuy·∫øn
  console.log('üìç ƒêang load waypoints t·ª´ server...');
  await loadRouteWaypoints('R001');
  await loadRouteWaypoints('R002');
  
  console.log(`\nüöç ƒêang theo d√µi ${buses.length} xe:`);
  buses.forEach(bus => {
    const waypoints = ROUTE_WAYPOINTS[bus.routeId];
    console.log(`  - ${bus.name} (${bus.id}) - Tuy·∫øn ${bus.routeId} (${waypoints ? waypoints.length : 0} ƒëi·ªÉm)`);
  });
  console.log('\nüîÑ C·∫≠p nh·∫≠t v·ªã tr√≠ m·ªói 2 gi√¢y. Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng.\n');
  
  // C·∫≠p nh·∫≠t m·ªói 2 gi√¢y
  setInterval(() => {
    buses.forEach(bus => {
      // Ch·ªâ c·∫≠p nh·∫≠t xe ƒëang di chuy·ªÉn (speed > 0)
      if (bus.speed > 0) {
        updateBusLocation(bus);
      }
    });
  }, 2000);
}

// B·∫Øt ƒë·∫ßu
startSimulator().catch(err => {
  console.error('‚ùå L·ªói kh·ªüi ƒë·ªông simulator:', err);
  process.exit(1);
});
